import type { Sveltin } from '$sveltin';

export async function list() {
	const contentFiles = import.meta.glob('/{{ .Settings.Paths.Content }}/{{ .Resource.Name }}/**/*.{svelte.md,md,svx}');
	const contentFilesArray = Object.entries(contentFiles);
	const contents: Array<Sveltin.MdSveXComponent> = await Promise.all(
		contentFilesArray.map(async ([path, resolver]) => {
			const data = await resolver();
			const result = {
				meta: data['metadata'],
				path: path
			} satisfies Sveltin.MdSveXComponent;
			return result;
		})
	);
	const publishedByDate = contents
		.filter((elem) => !elem.meta['draft'])
		.sort((a, b) => (a.meta['created_at'] < b.meta['created_at'] ? 1 : -1));

	return publishedByDate;
};

{{ $slugName := .Resource.Name | ToSlug}}
export async function getSingle(slug: string) {
	const resourceName = '{{ $slugName }}';
	const publishedByDate = await list();

	const selected = publishedByDate.filter((item) => item.meta['slug'] == slug);

	if (selected.length != 0) {
		const selectedItemIndex = publishedByDate.findIndex((elem) => slug === elem.meta['slug']);
		const selectedItem = publishedByDate[selectedItemIndex];

		const current = {
			resource: resourceName,
			metadata: selectedItem.meta as Sveltin.YAMLFrontmatter
		} satisfies Sveltin.ResourceContent;

		const previous = {
			resource: resourceName,
			metadata: {
				title: publishedByDate[selectedItemIndex + 1]?.meta['title'],
				slug: publishedByDate[selectedItemIndex + 1]?.meta['slug']
			} as Sveltin.YAMLFrontmatter
		} satisfies Sveltin.ResourceContent;

		const next = {
			resource: resourceName,
			metadata: {
				title: publishedByDate[selectedItemIndex - 1]?.meta['title'],
				slug: publishedByDate[selectedItemIndex - 1]?.meta['slug']
			} as Sveltin.YAMLFrontmatter
		} satisfies Sveltin.ResourceContent;

		return {
			status: 200,
			current,
			previous,
			next
		};
	}
	return {
		status: 404
	};
};
