import type { Sveltin } from '$sveltin';
import { orderBy } from '@sveltinio/ts-utils/collections';

export async function list(orderdByDate = true) {
	const contentFiles = import.meta.glob('/{{ .Settings.Paths.Content }}/{{ .Resource.Name }}/**/*.{svelte.md,md,svx}');
	const contentFilesArray = Object.entries(contentFiles);

	let contents: Array<Sveltin.MdSveXComponent> = await Promise.all(
		contentFilesArray.map(async ([path, resolver]) => {
			const data = (await resolver()) as Sveltin.MdSveXResolver;
			const { metadata: meta } = data;

			return {
				meta,
				path
			} satisfies Sveltin.MdSveXComponent;
		})
	);

	contents = contents.filter((elem) => !elem.meta['draft']);
	if (orderdByDate) {
		return orderBy(contents, 'meta.created_at');
	}

	return contents;
};

{{ $slugName := .Resource.Name | ToSlug}}
export async function getSingle(slug: string) {
	const resource = '{{ $slugName }}';
	const contentList = await list();
	const selected = contentList.filter((item) => item.meta['slug'] == slug);

	if (selected.length != 0) {
		const selectedIndex = contentList.findIndex((elem) => slug === elem.meta['slug']);
		const selected = contentList[selectedIndex];

		const current = {
			metadata: selected.meta as Sveltin.YAMLFrontmatter
		} satisfies Sveltin.ResourceContent;

		const previous = {
			metadata: {
				title: contentList[selectedIndex + 1]?.meta['title'],
				slug: contentList[selectedIndex + 1]?.meta['slug']
			} as Sveltin.YAMLFrontmatter
		} satisfies Sveltin.ResourceContent;

		const next = {
			metadata: {
				title: contentList[selectedIndex - 1]?.meta['title'],
				slug: contentList[selectedIndex - 1]?.meta['slug']
			} as Sveltin.YAMLFrontmatter
		} satisfies Sveltin.ResourceContent;

		return {
			status: 200,
			resource,
			current,
			previous,
			next
		};
	}
	return {
		status: 404
	};
};
